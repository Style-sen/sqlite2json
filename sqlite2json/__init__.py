import sqlite3
import json
import os


def tables(connection):
    query = "SELECT name FROM sqlite_master WHERE type='table'"
    return [r[0] for r in connection.execute(query, ())]


def table_content(connection, table):
    connection.row_factory = sqlite3.Row  # http://stackoverflow.com/questions/7831371/
    return [{key: value for (key, value) in zip(r.keys(), r)}
            for r in connection.execute("SELECT * FROM %s" % table, ())]


def content(connection):
    return {table: table_content(connection, table) for table in tables(connection)}


def save_json(connection, json_fp, pretty=False):
    if pretty:
        json.dump(content(connection), json_fp, sort_keys=True, indent=4, separators=(',', ': '))
    else:
        json.dump(content(connection), json_fp)


def save_schema(connection, schema_fp):
    for r in connection.execute("SELECT sql FROM sqlite_master WHERE type='table' and name<>'sqlite_sequence'"):
        schema_fp.write(r[0])
        schema_fp.write(';\n\n')


def load_schema(connection, schema_fp):
    connection.executescript(schema_fp.read())
    connection.commit()


def load_content_obj(connection, data):
    """
    Imports data from a dictionary to the database. The dictionary has to be in the format generated by content()
    
    Returns the number of records inserted 
    
    Input example: 
     {
         'tablename1': [
            { 'fieldname1' : 'value', 'fieldname2': 'value'},
            { 'fieldname1' : 'value', 'fieldname2': 'value'},
         ] ,
         'tablename2': [
             { 'fieldname3': 'value' },
             { 'fieldname3': 'value' }
        ]
    } 
    """

    def insertion_generator():
        for table, rows in data.items():
            for row in rows:
                fields = [(k, v) for (k, v) in row.items()]  # extra defensive programming to make the order matches
                field_names = ', '.join(field[0] for field in fields)
                question_marks = ', '.join(['?'] * len(fields))
                field_values = tuple(str(field[1]) for field in fields)
                query = 'INSERT INTO {} ({}) VALUES ({})'.format(table, field_names, question_marks)
                yield query, field_values

    count = -1
    for count, (q, v) in enumerate(insertion_generator()):
        connection.execute(q, v)
    connection.commit()
    return count + 1


def load_content(connection, fp):
    """Imports from a file pointer to the database"""
    return load_content_obj(connection, json.load(fp))


def create_backup(connection, json_filename, schema_filename, pretty):
    with open(json_filename, 'w', encoding='utf8') as f:
        save_json(connection, f, pretty)
    with open(schema_filename, 'w', encoding='utf8') as f:
        save_schema(connection, f)


def backup_in_same_folder(db_filename, pretty=False):
    """
    Create a backup for a database, including schema & content. 
    
    The backup will be created in the same folder as the database file. The file names for the schema and the json
    will be based on the database name. 
    """
    (directory, file_name) = os.path.split(db_filename)
    base_file = os.path.splitext(file_name)[0]
    with sqlite3.connect(db_filename) as db:
        create_backup(db, os.path.join(directory, base_file + ".json"),
                      os.path.join(directory, base_file + "_schema.sql"), pretty)


def backup_connection(connection, output_folder, pretty=False):
    create_backup(connection,
                  os.path.join(output_folder, 'data.json'),
                  os.path.join(output_folder, 'schema.sql'),
                  pretty)


def load_backup(db_filename, schema_filename, content_filename):
    """Load database from backup created using create_backup()"""
    with sqlite3.connect(db_filename) as db:
        with open(schema_filename) as f:
            load_schema(db, f)
        with open(content_filename) as f:
            load_content(db, f)
